<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ModelAnalyser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Digital</a> &gt; <a href="index.source.html" class="el_package">de.neemann.digital.analyse</a> &gt; <span class="el_source">ModelAnalyser.java</span></div><h1>ModelAnalyser.java</h1><pre class="source lang-java linenums">/*
 * Copyright (c) 2016 Helmut Neemann
 * Use of this source code is governed by the GPL v3 license
 * that can be found in the LICENSE file.
 */
package de.neemann.digital.analyse;

import de.neemann.digital.analyse.expression.BitSetter;
import de.neemann.digital.analyse.quinemc.BoolTableByteArray;
import de.neemann.digital.core.*;
import de.neemann.digital.core.flipflops.FlipflopD;
import de.neemann.digital.core.switching.NFET;
import de.neemann.digital.core.switching.Relay;
import de.neemann.digital.core.switching.RelayDT;
import de.neemann.digital.core.wiring.Clock;
import de.neemann.digital.core.wiring.Splitter;
import de.neemann.digital.draw.elements.PinException;
import de.neemann.digital.gui.Main;
import de.neemann.digital.lang.Lang;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;

/**
 * Analyses a given model.
 * Calculates the truth table which is generated by the given model
 */
public class ModelAnalyser {
<span class="fc" id="L31">    private static final Logger LOGGER = LoggerFactory.getLogger(ModelAnalyser.class);</span>
    private static final int MAX_INPUTS_ALLOWED = 24;

    private final Model model;
    private final ArrayList&lt;Signal&gt; inputs;
    private final ArrayList&lt;Signal&gt; outputs;
    private ModelAnalyserInfo modelAnalyzerInfo;

    /**
     * Creates a new instance
     *
     * @param model the model
     * @throws AnalyseException AnalyseException
     */
<span class="fc" id="L45">    public ModelAnalyser(Model model) throws AnalyseException {</span>
<span class="fc" id="L46">        this.model = model;</span>

<span class="fc" id="L48">        modelAnalyzerInfo = new ModelAnalyserInfo(model);</span>

<span class="fc" id="L50">        inputs = checkBinaryInputs(model.getInputs());</span>
<span class="fc" id="L51">        checkUnique(inputs);</span>
<span class="fc" id="L52">        outputs = checkBinaryOutputs(model.getOutputs());</span>

<span class="fc" id="L54">        modelAnalyzerInfo.setInOut(inputs, outputs);</span>

<span class="fc bfc" id="L56" title="All 2 branches covered.">        for (Node n : model)</span>
<span class="pc bpc" id="L57" title="1 of 4 branches missed.">            if (n.hasState() &amp;&amp; !(n instanceof FlipflopD))</span>
<span class="nc" id="L58">                throw new AnalyseException(Lang.get(&quot;err_cannotAnalyse_N&quot;, n.getClass().getSimpleName()));</span>

<span class="fc" id="L60">        int i = 0;</span>
<span class="fc" id="L61">        List&lt;FlipflopD&gt; flipflops = model.findNode(FlipflopD.class);</span>
<span class="fc" id="L62">        flipflops = replaceMultiBitFlipflops(flipflops);</span>
<span class="fc bfc" id="L63" title="All 2 branches covered.">        for (FlipflopD ff : flipflops) {</span>
<span class="fc" id="L64">            checkClock(ff);</span>
<span class="pc bpc" id="L65" title="1 of 2 branches missed.">            if (ff.getDataBits() != 1)</span>
<span class="nc" id="L66">                throw new AnalyseException(Lang.get(&quot;err_MultiBitFlipFlopFound&quot;));</span>

<span class="fc" id="L68">            ff.getDInput().removeObserver(ff); // turn off flipflop</span>
<span class="fc" id="L69">            String label = getUniqueNameFor(ff);</span>

<span class="fc" id="L71">            outputs.add(i++, new Signal(addOne(label), ff.getDInput()));</span>

<span class="fc" id="L73">            modelAnalyzerInfo.setSequentialInitValue(label, ff.getDefault());</span>

<span class="fc" id="L75">            ObservableValue q = ff.getOutputs().get(0);</span>
<span class="fc" id="L76">            final Signal sig = new Signal(label, q);</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">            if (inputs.contains(sig))</span>
<span class="nc" id="L78">                throw new AnalyseException(Lang.get(&quot;err_varName_N_UsedTwice&quot;, sig.getName()));</span>
<span class="fc" id="L79">            inputs.add(sig);</span>

<span class="fc" id="L81">            ObservableValue notQ = ff.getOutputs().get(1);</span>
<span class="fc" id="L82">            q.addObserver(new NodeWithoutDelay(notQ) {</span>
                @Override
                public void hasChanged() {
<span class="fc" id="L85">                    notQ.setValue(~q.getValue());</span>
<span class="fc" id="L86">                }</span>
            });
<span class="fc" id="L88">        }</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (inputs.size() == 0)</span>
<span class="nc" id="L91">            throw new AnalyseException(Lang.get(&quot;err_analyseNoInputs&quot;));</span>
<span class="pc bpc" id="L92" title="1 of 2 branches missed.">        if (outputs.size() == 0)</span>
<span class="nc" id="L93">            throw new AnalyseException(Lang.get(&quot;err_analyseNoOutputs&quot;));</span>
<span class="fc" id="L94">    }</span>

    /**
     * Adds the &quot;+1&quot; to the variables name
     *
     * @param name the vars name
     * @return the modified name
     */
    public static String addOne(String name) {
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (name.endsWith(&quot;^n&quot;))</span>
<span class="fc" id="L104">            return name.substring(0, name.length() - 1) + &quot;{n+1}&quot;;</span>
        else
<span class="fc" id="L106">            return name + &quot;+1&quot;;</span>
    }


    private String getUniqueNameFor(FlipflopD ff) {
<span class="fc" id="L111">        String label = ff.getLabel();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">        if (label.length() == 0)</span>
<span class="fc" id="L113">            label = createOutputBasedName(ff);</span>

<span class="fc bfc" id="L115" title="All 2 branches covered.">        if (!label.endsWith(&quot;n&quot;))</span>
<span class="fc" id="L116">            label += &quot;^n&quot;;</span>

<span class="fc" id="L118">        return new LabelNumbering(label).create(this::inputExist);</span>
    }

    private boolean inputExist(String label) {
<span class="fc bfc" id="L122" title="All 2 branches covered.">        for (Signal i : inputs)</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">            if (i.getName().equals(label))</span>
<span class="fc" id="L124">                return true;</span>
<span class="fc" id="L125">        return false;</span>
    }

    private String createOutputBasedName(FlipflopD ff) {
<span class="fc" id="L129">        ObservableValue q = ff.getOutputs().get(0);</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        for (Signal o : outputs) {</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">            if (o.getValue() == q)</span>
<span class="fc" id="L132">                return o.getName();</span>
<span class="fc" id="L133">        }</span>

<span class="fc" id="L135">        return &quot;Z&quot;;</span>
    }

    private void checkUnique(ArrayList&lt;Signal&gt; signals) throws AnalyseException {
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (int i = 0; i &lt; signals.size() - 1; i++)</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">            for (int j = i + 1; j &lt; signals.size(); j++)</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">                if (signals.get(i).equals(signals.get(j)))</span>
<span class="fc" id="L142">                    throw new AnalyseException(Lang.get(&quot;err_varName_N_UsedTwice&quot;, signals.get(i).getName()));</span>
<span class="fc" id="L143">    }</span>

    private ArrayList&lt;Signal&gt; checkBinaryOutputs(ArrayList&lt;Signal&gt; list) throws AnalyseException {
<span class="fc" id="L146">        ArrayList&lt;Signal&gt; outputs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">        for (Signal s : list) {</span>
<span class="fc" id="L148">            final int bits = s.getValue().getBits();</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            if (bits == 1)</span>
<span class="fc" id="L150">                outputs.add(s);</span>
            else {
                try {
<span class="fc" id="L153">                    Splitter sp = Splitter.createOneToN(bits);</span>
<span class="fc" id="L154">                    sp.setInputs(s.getValue().asList());</span>
<span class="fc" id="L155">                    SplitPinString pins = SplitPinString.create(s);</span>

<span class="fc" id="L157">                    final ObservableValues spOutputs = sp.getOutputs();</span>
<span class="fc" id="L158">                    String name = s.getName();</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">                    if (!name.contains(&quot;_&quot;))</span>
<span class="fc" id="L160">                        name += &quot;_&quot;;</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">                    for (int i = spOutputs.size() - 1; i &gt;= 0; i--)</span>
<span class="fc" id="L162">                        outputs.add(new Signal(name + i, spOutputs.get(i)).setPinNumber(pins.getPin(i)));</span>

<span class="fc" id="L164">                    s.getValue().fireHasChanged();</span>

<span class="fc" id="L166">                    ArrayList&lt;String&gt; names = new ArrayList&lt;&gt;(bits);</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">                    for (int i = 0; i &lt; bits; i++)</span>
<span class="fc" id="L168">                        names.add(name + i);</span>

<span class="fc" id="L170">                    modelAnalyzerInfo.addOutputBus(s.getName(), names);</span>

<span class="nc" id="L172">                } catch (NodeException e) {</span>
<span class="nc" id="L173">                    throw new AnalyseException(e);</span>
<span class="fc" id="L174">                }</span>
            }
<span class="fc" id="L176">        }</span>
<span class="fc" id="L177">        return outputs;</span>
    }

    private ArrayList&lt;Signal&gt; checkBinaryInputs(ArrayList&lt;Signal&gt; list) throws AnalyseException {
<span class="fc" id="L181">        ArrayList&lt;Signal&gt; inputs = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for (Signal s : list) {</span>
<span class="pc bpc" id="L183" title="1 of 2 branches missed.">            if (!ignoreSignal(s)) {</span>
<span class="fc" id="L184">                final int bits = s.getValue().getBits();</span>
<span class="fc bfc" id="L185" title="All 2 branches covered.">                if (bits == 1)</span>
<span class="fc" id="L186">                    inputs.add(s);</span>
                else {
                    try {
<span class="fc" id="L189">                        Splitter sp = Splitter.createNToOne(bits);</span>
<span class="fc" id="L190">                        final ObservableValue out = sp.getOutputs().get(0);</span>
<span class="fc" id="L191">                        out.addObserver(new NodeWithoutDelay(s.getValue()) {</span>
                            @Override
                            public void hasChanged() {
<span class="fc" id="L194">                                s.getValue().setValue(out.getValue());</span>
<span class="fc" id="L195">                            }</span>
                        });
<span class="fc" id="L197">                        out.fireHasChanged();</span>

<span class="fc" id="L199">                        SplitPinString pins = SplitPinString.create(s);</span>
<span class="fc" id="L200">                        ObservableValues.Builder builder = new ObservableValues.Builder();</span>
<span class="fc" id="L201">                        String name = s.getName();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">                        if (!name.contains(&quot;_&quot;))</span>
<span class="fc" id="L203">                            name += &quot;_&quot;;</span>
<span class="fc bfc" id="L204" title="All 2 branches covered.">                        for (int i = bits - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L205">                            ObservableValue o = new ObservableValue(name + i, 1);</span>
<span class="fc" id="L206">                            builder.add(o);</span>
<span class="fc" id="L207">                            inputs.add(new Signal(name + i, o).setPinNumber(pins.getPin(i)));</span>
                        }
<span class="fc" id="L209">                        final ObservableValues inputsList = builder.reverse().build();</span>
<span class="fc" id="L210">                        sp.setInputs(inputsList);</span>

<span class="fc" id="L212">                        modelAnalyzerInfo.addInputBus(s.getName(), inputsList.getNames());</span>

<span class="nc" id="L214">                    } catch (NodeException e) {</span>
<span class="nc" id="L215">                        throw new AnalyseException(e);</span>
<span class="fc" id="L216">                    }</span>
                }
            }
<span class="fc" id="L219">        }</span>
<span class="fc" id="L220">        return inputs;</span>
    }

    private boolean ignoreSignal(Signal s) {
<span class="pc bpc" id="L224" title="2 of 4 branches missed.">        return s.getName().equals(&quot;VCC&quot;) || s.getName().equals(&quot;GND&quot;);</span>
    }

    private void checkClock(Node node) throws AnalyseException {
<span class="pc bpc" id="L228" title="1 of 2 branches missed.">        if (!getClock().hasObserver(node))</span>
<span class="nc" id="L229">            throw new AnalyseException(Lang.get(&quot;err_ffNeedsToBeConnectedToClock&quot;));</span>
<span class="fc" id="L230">    }</span>

    private ObservableValue getClock() throws AnalyseException {
<span class="fc" id="L233">        ArrayList&lt;Clock&gt; clocks = model.getClocks();</span>
<span class="pc bpc" id="L234" title="1 of 2 branches missed.">        if (clocks.size() != 1)</span>
<span class="nc" id="L235">            throw new AnalyseException(Lang.get(&quot;err_aSingleClockNecessary&quot;));</span>
<span class="fc" id="L236">        return clocks.get(0).getClockOutput();</span>
    }

    private List&lt;FlipflopD&gt; replaceMultiBitFlipflops(List&lt;FlipflopD&gt; flipflops) throws AnalyseException {
<span class="fc" id="L240">        ArrayList&lt;FlipflopD&gt; out = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        for (FlipflopD ff : flipflops) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">            if (ff.getDataBits() == 1)</span>
<span class="fc" id="L243">                out.add(ff);</span>
            else {
                try {
<span class="fc" id="L246">                    model.removeNode(ff);</span>
<span class="fc" id="L247">                    ff.getDInput().removeObserver(ff);</span>
<span class="fc" id="L248">                    ff.getClock().removeObserver(ff);</span>

<span class="fc" id="L250">                    Splitter insp = Splitter.createOneToN(ff.getDataBits());</span>
<span class="fc" id="L251">                    insp.setInputs(new ObservableValues(ff.getDInput()));</span>
<span class="fc" id="L252">                    ff.getDInput().fireHasChanged();</span>

<span class="fc" id="L254">                    Splitter outsp = Splitter.createNToOne(ff.getDataBits());</span>

<span class="fc" id="L256">                    ObservableValues.Builder spinput = new ObservableValues.Builder();</span>
<span class="fc" id="L257">                    String label = ff.getLabel();</span>
<span class="fc bfc" id="L258" title="All 2 branches covered.">                    if (label.length() == 0)</span>
<span class="fc" id="L259">                        label = createOutputBasedName(ff);</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">                    if (!label.contains(&quot;_&quot;))</span>
<span class="fc" id="L261">                        label = label + &quot;_&quot;;</span>
<span class="fc" id="L262">                    long def = ff.getDefault();</span>
<span class="fc bfc" id="L263" title="All 2 branches covered.">                    for (int i = ff.getDataBits() - 1; i &gt;= 0; i--) {</span>
<span class="fc" id="L264">                        ObservableValue qn = new ObservableValue(&quot;&quot;, 1);</span>
<span class="fc" id="L265">                        ObservableValue nqn = new ObservableValue(&quot;&quot;, 1);</span>
<span class="pc bpc" id="L266" title="1 of 2 branches missed.">                        FlipflopD newff = new FlipflopD(label + i, qn, nqn, (def &amp; (1L &lt;&lt; i)) != 0 ? 1 : 0);</span>
<span class="fc" id="L267">                        spinput.addAtTop(qn);</span>
<span class="fc" id="L268">                        model.add(newff);</span>
<span class="fc" id="L269">                        newff.setInputs(new ObservableValues(insp.getOutputs().get(i), getClock()));</span>
<span class="fc" id="L270">                        out.add(newff);</span>
                    }
<span class="fc" id="L272">                    outsp.setInputs(spinput.build());</span>
<span class="fc bfc" id="L273" title="All 2 branches covered.">                    for (ObservableValue v : spinput)</span>
<span class="fc" id="L274">                        v.fireHasChanged();</span>

<span class="fc" id="L276">                    final ObservableValue qout = ff.getOutputs().get(0);</span>
<span class="fc" id="L277">                    final ObservableValue nqout = ff.getOutputs().get(1);</span>
<span class="fc" id="L278">                    ObservableValue spq = outsp.getOutputs().get(0);</span>
<span class="fc" id="L279">                    spq.addObserver(new NodeWithoutDelay(qout, nqout) {</span>
                        @Override
                        public void hasChanged() {
<span class="fc" id="L282">                            final long value = spq.getValue();</span>
<span class="fc" id="L283">                            qout.setValue(value);</span>
<span class="fc" id="L284">                            nqout.setValue(~value);</span>
<span class="fc" id="L285">                        }</span>
                    });
<span class="fc" id="L287">                    spq.fireHasChanged();</span>

<span class="nc" id="L289">                } catch (NodeException e) {</span>
<span class="nc" id="L290">                    throw new AnalyseException(e);</span>
<span class="fc" id="L291">                }</span>
            }
<span class="fc" id="L293">        }</span>
<span class="fc" id="L294">        return out;</span>
    }

    /**
     * @return the models inputs
     */
    public ArrayList&lt;Signal&gt; getInputs() {
<span class="fc" id="L301">        return inputs;</span>
    }

    /**
     * @return the models outputs
     */
    public ArrayList&lt;Signal&gt; getOutputs() {
<span class="fc" id="L308">        return outputs;</span>
    }

    /**
     * Calculates the max depth of the circuit.
     * The max path length is the max number of gates in between any of the inputs and
     * any of the outputs.
     *
     * @return the maximum path len
     * @throws PinException       PinException
     * @throws BacktrackException BacktrackException
     * @throws AnalyseException   AnalyseException
     */
    public int calcMaxPathLen() throws PinException, BacktrackException, AnalyseException {
<span class="nc" id="L322">        LOGGER.debug(&quot;start to calculate the depth of the model...&quot;);</span>

<span class="nc bnc" id="L324" title="All 4 branches missed.">        if (!Main.isExperimentalMode() &amp;&amp; !modelContainsSwitches())</span>
<span class="nc" id="L325">            CycleDetector.checkForCycles(inputs);</span>

<span class="nc" id="L327">        DependencyAnalyser da = new DependencyAnalyser(this);</span>
<span class="nc" id="L328">        return da.getMaxPathLen();</span>
    }

    /**
     * Analyses the circuit
     *
     * @return the generated truth table
     * @throws NodeException      NodeException
     * @throws PinException       PinException
     * @throws BacktrackException BacktrackException
     * @throws AnalyseException   AnalyseException
     */
    public TruthTable analyse() throws NodeException, PinException, BacktrackException, AnalyseException {
<span class="fc" id="L341">        LOGGER.debug(&quot;start to analyse the model...&quot;);</span>

<span class="fc" id="L343">        TruthTable tt = new TruthTable();</span>
<span class="fc" id="L344">        tt.setModelAnalyzerInfo(getModelAnalyzerInfo());</span>
<span class="fc bfc" id="L345" title="All 2 branches covered.">        for (Signal s : inputs)</span>
<span class="fc" id="L346">            tt.addVariable(s.getName());</span>

<span class="pc bpc" id="L348" title="2 of 4 branches missed.">        if (!Main.isExperimentalMode() &amp;&amp; !modelContainsSwitches())</span>
<span class="fc" id="L349">            CycleDetector.checkForCycles(inputs);</span>

<span class="fc" id="L351">        DependencyAnalyser da = new DependencyAnalyser(this);</span>
<span class="fc" id="L352">        long steps = da.getRequiredSteps(this);</span>

<span class="fc" id="L354">        long tableRows = 1L &lt;&lt; inputs.size();</span>
<span class="fc" id="L355">        LOGGER.debug(&quot;analyse speedup: &quot; + tableRows + &quot; rows vs &quot; + steps + &quot; steps, speedup &quot; + ((double) tableRows) / steps);</span>

<span class="fc" id="L357">        long time = System.currentTimeMillis();</span>


<span class="pc bpc" id="L360" title="1 of 4 branches missed.">        if (tableRows &lt;= steps || tableRows &lt;= 128)</span>
<span class="fc" id="L361">            simpleFiller(tt);</span>
        else
<span class="fc" id="L363">            dependantFiller(tt, da);</span>

<span class="fc" id="L365">        time = System.currentTimeMillis() - time;</span>
<span class="fc" id="L366">        LOGGER.debug(&quot;model analysis: &quot; + time / 1000.0 + &quot; sec&quot;);</span>

<span class="fc" id="L368">        return tt;</span>
    }

    private boolean modelContainsSwitches() {
<span class="fc bfc" id="L372" title="All 2 branches covered.">        for (Node n : model)</span>
<span class="pc bpc" id="L373" title="3 of 6 branches missed.">            if (n instanceof Relay</span>
                    || n instanceof RelayDT
<span class="nc" id="L375">                    || n instanceof NFET) return true;</span>
<span class="fc" id="L376">        return false;</span>
    }

    private void simpleFiller(TruthTable tt) throws NodeException, AnalyseException {
<span class="pc bpc" id="L380" title="1 of 2 branches missed.">        if (inputs.size() &gt; MAX_INPUTS_ALLOWED)</span>
<span class="nc" id="L381">            throw new AnalyseException(Lang.get(&quot;err_toManyInputs_max_N0_is_N1&quot;, MAX_INPUTS_ALLOWED, inputs.size()));</span>


<span class="fc" id="L384">        BitSetter bitsetter = new BitSetter(inputs.size()) {</span>
            @Override
            public void setBit(int row, int bit, boolean value) {
<span class="fc" id="L387">                inputs.get(bit).getValue().setBool(value);</span>
<span class="fc" id="L388">            }</span>
        };

<span class="fc" id="L391">        int rows = 1 &lt;&lt; inputs.size();</span>
<span class="fc" id="L392">        ArrayList&lt;BoolTableByteArray&gt; data = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L393" title="All 2 branches covered.">        for (Signal s : outputs) {</span>
<span class="fc" id="L394">            BoolTableByteArray e = new BoolTableByteArray(rows);</span>
<span class="fc" id="L395">            data.add(e);</span>
<span class="fc" id="L396">            tt.addResult(s.getName(), e);</span>
<span class="fc" id="L397">        }</span>

<span class="fc" id="L399">        model.init();</span>
<span class="fc bfc" id="L400" title="All 2 branches covered.">        for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc" id="L401">            bitsetter.fill(row);</span>
<span class="fc" id="L402">            model.doStep();</span>
<span class="fc bfc" id="L403" title="All 2 branches covered.">            for (int i = 0; i &lt; outputs.size(); i++) {</span>
<span class="fc" id="L404">                data.get(i).set(row, outputs.get(i).getValue().getBool());</span>
            }
        }
<span class="fc" id="L407">    }</span>

    private void dependantFiller(TruthTable tt, DependencyAnalyser da) throws NodeException, AnalyseException {
<span class="fc" id="L410">        model.init();</span>
<span class="fc bfc" id="L411" title="All 2 branches covered.">        for (Signal out : outputs) {</span>

<span class="fc" id="L413">            ArrayList&lt;Signal&gt; ins = reorder(da.getInputs(out), inputs);</span>
<span class="pc bpc" id="L414" title="1 of 2 branches missed.">            if (ins.size() &gt; MAX_INPUTS_ALLOWED)</span>
<span class="nc" id="L415">                throw new AnalyseException(Lang.get(&quot;err_toManyInputs_max_N0_is_N1&quot;, MAX_INPUTS_ALLOWED, ins.size()));</span>

<span class="fc" id="L417">            int rows = 1 &lt;&lt; ins.size();</span>
<span class="fc" id="L418">            BoolTableByteArray e = new BoolTableByteArray(rows);</span>
<span class="fc" id="L419">            BitSetter bitsetter = new BitSetter(ins.size()) {</span>
                @Override
                public void setBit(int row, int bit, boolean value) {
<span class="fc" id="L422">                    ins.get(bit).getValue().setBool(value);</span>
<span class="fc" id="L423">                }</span>
            };

<span class="fc bfc" id="L426" title="All 2 branches covered.">            for (int row = 0; row &lt; rows; row++) {</span>
<span class="fc" id="L427">                bitsetter.fill(row);</span>
<span class="fc" id="L428">                model.doStep();</span>
<span class="fc" id="L429">                e.set(row, out.getValue().getBool());</span>
            }

<span class="fc" id="L432">            tt.addResult(out.getName(), new BoolTableExpanded(e, ins, inputs));</span>
<span class="fc" id="L433">        }</span>
<span class="fc" id="L434">    }</span>

    private ModelAnalyserInfo getModelAnalyzerInfo() {
<span class="fc" id="L437">        return modelAnalyzerInfo;</span>
    }

    private ArrayList&lt;Signal&gt; reorder(ArrayList&lt;Signal&gt; ins, ArrayList&lt;Signal&gt; originalOrder) {
<span class="fc" id="L441">        ArrayList&lt;Signal&gt; newList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L442" title="All 2 branches covered.">        for (Signal i : originalOrder)</span>
<span class="fc bfc" id="L443" title="All 2 branches covered.">            if (ins.contains(i))</span>
<span class="fc" id="L444">                newList.add(i);</span>
<span class="fc" id="L445">        return newList;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>